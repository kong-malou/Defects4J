diff --git a/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java b/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java
index 18c0ae2..3d33212 100644
--- a/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java
+++ b/guava-tests/test/com/google/common/collect/MinMaxPriorityQueueTest.java
@@ -22,10 +22,6 @@ import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.testing.IteratorFeature;
 import com.google.common.collect.testing.IteratorTester;
-import com.google.common.collect.testing.QueueTestSuiteBuilder;
-import com.google.common.collect.testing.TestStringQueueGenerator;
-import com.google.common.collect.testing.features.CollectionFeature;
-import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.testing.NullPointerTester;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -37,13 +33,10 @@ import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.PriorityQueue;
-import java.util.Queue;
 import java.util.Random;
 import java.util.SortedMap;
 import java.util.concurrent.atomic.AtomicInteger;
-import junit.framework.Test;
 import junit.framework.TestCase;
-import junit.framework.TestSuite;
 
 /**
  * Unit test for {@link MinMaxPriorityQueue}.
@@ -53,23 +46,7 @@ import junit.framework.TestSuite;
  */
 @GwtCompatible(emulated = true)
 public class MinMaxPriorityQueueTest extends TestCase {
-  private static final Ordering<Integer> SOME_COMPARATOR = Ordering.natural().reverse();
-
-  @GwtIncompatible // suite
-  public static Test suite() {
-    TestSuite suite = new TestSuite();
-    suite.addTestSuite(MinMaxPriorityQueueTest.class);
-    suite.addTest(QueueTestSuiteBuilder
-        .using(new TestStringQueueGenerator() {
-          @Override protected Queue<String> create(String[] elements) {
-            return MinMaxPriorityQueue.create(Arrays.asList(elements));
-          }
-        })
-        .named("MinMaxPriorityQueue")
-        .withFeatures(CollectionSize.ANY, CollectionFeature.GENERAL_PURPOSE)
-        .createTestSuite());
-    return suite;
-  }
+  private Ordering<Integer> SOME_COMPARATOR = Ordering.natural().reverse();
 
   // Overkill alert!  Test all combinations of 0-2 options during creation.
 
@@ -249,8 +226,8 @@ public class MinMaxPriorityQueueTest extends TestCase {
       }
     }
     assertEquals(currentHeapSize, mmHeap.size());
-    assertTrue("Heap not intact after " + numberOfModifications
-        + " random mixture of operations", mmHeap.isIntact());
+    assertTrue("Heap not intact after " + numberOfModifications +
+        " random mixture of operations", mmHeap.isIntact());
   }
 
   public void testSmall() {
@@ -766,58 +743,6 @@ public class MinMaxPriorityQueueTest extends TestCase {
   }
 
   /**
-   * Regression test for https://github.com/google/guava/issues/2658
-   */
-  public void testRemoveRegression() {
-    MinMaxPriorityQueue<Long> queue =
-        MinMaxPriorityQueue.create(ImmutableList.of(2L, 3L, 0L, 4L, 1L));
-    queue.remove(4L);
-    queue.remove(1L);
-    assertThat(queue).doesNotContain(1L);
-  }
-
-  public void testRandomRemoves() {
-    Random random = new Random(0);
-    for (int attempts = 0; attempts < 1000; attempts++) {
-      ArrayList<Integer> elements = createOrderedList(10);
-      Collections.shuffle(elements, random);
-      MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create(elements);
-      Collections.shuffle(elements, random);
-      for (Integer element : elements) {
-        assertThat(queue.remove(element)).isTrue();
-        assertThat(queue.isIntact()).isTrue();
-        assertThat(queue).doesNotContain(element);
-      }
-      assertThat(queue).isEmpty();
-    }
-  }
-
-  public void testRandomAddsAndRemoves() {
-    Random random = new Random(0);
-    Multiset<Integer> elements = HashMultiset.create();
-    MinMaxPriorityQueue<Integer> queue = MinMaxPriorityQueue.create();
-    int range = 10_000; // range should be small enough that equal elements occur semi-frequently
-    for (int iter = 0; iter < 1000; iter++) {
-      for (int i = 0; i < 100; i++) {
-        Integer element = random.nextInt(range);
-        elements.add(element);
-        queue.add(element);
-      }
-      Iterator<Integer> queueIterator = queue.iterator();
-      while (queueIterator.hasNext()) {
-        Integer element = queueIterator.next();
-        assertThat(elements).contains(element);
-        if (random.nextBoolean()) {
-          elements.remove(element);
-          queueIterator.remove();
-        }
-      }
-      assertThat(queue.isIntact()).isTrue();
-      assertThat(queue).containsExactlyElementsIn(elements);
-    }
-  }
-
-  /**
    * Returns the seed used for the randomization.
    */
   private long insertRandomly(ArrayList<Integer> elements,
