diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java
index 6567e36..21558d2 100644
--- a/src/main/java/org/jsoup/helper/DataUtil.java
+++ b/src/main/java/org/jsoup/helper/DataUtil.java
@@ -2,7 +2,6 @@ package org.jsoup.helper;
 
 import org.jsoup.nodes.Document;
 import org.jsoup.nodes.Element;
-import org.jsoup.nodes.XmlDeclaration;
 import org.jsoup.parser.Parser;
 
 import java.io.ByteArrayOutputStream;
@@ -96,38 +95,51 @@ public final class DataUtil {
         Document doc = null;
 
         // look for BOM - overrides any other header or input
-        charsetName = detectCharsetFromBom(byteData, charsetName);
+        byteData.mark();
+        byte[] bom = new byte[4];
+        if (byteData.remaining() >= bom.length) {
+            byteData.get(bom);
+            byteData.rewind();
+        }
+        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE
+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE
+            charsetName = "UTF-32"; // and I hope it's on your system
+        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE
+                bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {
+            charsetName = "UTF-16"; // in all Javas
+        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {
+            charsetName = "UTF-8"; // in all Javas
+            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed
+        }
 
-        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
+        if (charsetName == null) { // determine from meta. safe parse as UTF-8
             // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">
             docData = Charset.forName(defaultCharset).decode(byteData).toString();
             doc = parser.parseInput(docData, baseUri);
             Element meta = doc.select("meta[http-equiv=content-type], meta[charset]").first();
-            String foundCharset = null; // if not found, will keep utf-8 as best attempt
-            if (meta != null) {
+            if (meta != null) { // if not found, will keep utf-8 as best attempt
+                String foundCharset = null;
                 if (meta.hasAttr("http-equiv")) {
                     foundCharset = getCharsetFromContentType(meta.attr("content"));
                 }
                 if (foundCharset == null && meta.hasAttr("charset")) {
-                    foundCharset = meta.attr("charset");
+                    try {
+                        if (Charset.isSupported(meta.attr("charset"))) {
+                            foundCharset = meta.attr("charset");
+                        }
+                    } catch (IllegalCharsetNameException e) {
+                        foundCharset = null;
+                    }
                 }
-            }
-            // look for <?xml encoding='ISO-8859-1'?>
-            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {
-                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
-                if (prolog.name().equals("xml")) {
-                    foundCharset = prolog.attr("encoding");
+
+                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
+                    foundCharset = foundCharset.trim().replaceAll("[\"']", "");
+                    charsetName = foundCharset;
+                    byteData.rewind();
+                    docData = Charset.forName(foundCharset).decode(byteData).toString();
+                    doc = null;
                 }
             }
-            foundCharset = validateCharset(foundCharset);
-
-            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode
-                foundCharset = foundCharset.trim().replaceAll("[\"']", "");
-                charsetName = foundCharset;
-                byteData.rewind();
-                docData = Charset.forName(foundCharset).decode(byteData).toString();
-                doc = null;
-            }
         } else { // specified by content type header (or by user on file load)
             Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
             docData = Charset.forName(charsetName).decode(byteData).toString();
@@ -202,20 +214,15 @@ public final class DataUtil {
         if (m.find()) {
             String charset = m.group(1).trim();
             charset = charset.replace("charset=", "");
-            return validateCharset(charset);
-        }
-        return null;
-    }
-
-    private static String validateCharset(String cs) {
-        if (cs == null || cs.length() == 0) return null;
-        cs = cs.trim().replaceAll("[\"']", "");
-        try {
-            if (Charset.isSupported(cs)) return cs;
-            cs = cs.toUpperCase(Locale.ENGLISH);
-            if (Charset.isSupported(cs)) return cs;
-        } catch (IllegalCharsetNameException e) {
-            // if our this charset matching fails.... we just take the default
+            if (charset.length() == 0) return null;
+            try {
+                if (Charset.isSupported(charset)) return charset;
+                charset = charset.toUpperCase(Locale.ENGLISH);
+                if (Charset.isSupported(charset)) return charset;
+            } catch (IllegalCharsetNameException e) {
+                // if our advanced charset matching fails.... we just take the default
+                return null;
+            }
         }
         return null;
     }
@@ -231,24 +238,4 @@ public final class DataUtil {
         }
         return mime.toString();
     }
-
-    private static String detectCharsetFromBom(ByteBuffer byteData, String charsetName) {
-        byteData.mark();
-        byte[] bom = new byte[4];
-        if (byteData.remaining() >= bom.length) {
-            byteData.get(bom);
-            byteData.rewind();
-        }
-        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE
-            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE
-            charsetName = "UTF-32"; // and I hope it's on your system
-        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE
-            bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {
-            charsetName = "UTF-16"; // in all Javas
-        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {
-            charsetName = "UTF-8"; // in all Javas
-            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here
-        }
-        return charsetName;
-    }
 }
diff --git a/src/main/java/org/jsoup/nodes/Document.java b/src/main/java/org/jsoup/nodes/Document.java
index 5751622..c7bfb1e 100644
--- a/src/main/java/org/jsoup/nodes/Document.java
+++ b/src/main/java/org/jsoup/nodes/Document.java
@@ -332,7 +332,7 @@ public class Document extends Element {
                 if (node instanceof XmlDeclaration) {
                     XmlDeclaration decl = (XmlDeclaration) node;
 
-                    if (decl.name().equals("xml")) {
+                    if (decl.attr(XmlDeclaration.DECL_KEY).equals("xml")) {
                         decl.attr("encoding", charset().displayName());
 
                         final String version = decl.attr("version");
diff --git a/src/main/java/org/jsoup/nodes/XmlDeclaration.java b/src/main/java/org/jsoup/nodes/XmlDeclaration.java
index 619cd14..10acfc2 100644
--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java
+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java
@@ -1,7 +1,5 @@
 package org.jsoup.nodes;
 
-import org.jsoup.helper.Validate;
-
 import java.io.IOException;
 
 /**
@@ -9,19 +7,18 @@ import java.io.IOException;
 
  @author Jonathan Hedley, jonathan@hedley.net */
 public class XmlDeclaration extends Node {
-    private final String name;
+    static final String DECL_KEY = "declaration";
     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)
 
     /**
      Create a new XML declaration
-     @param name of declaration
+     @param data data
      @param baseUri base uri
      @param isProcessingInstruction is processing instruction
      */
-    public XmlDeclaration(String name, String baseUri, boolean isProcessingInstruction) {
+    public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) {
         super(baseUri);
-        Validate.notNull(name);
-        this.name = name;
+        attributes.put(DECL_KEY, data);
         this.isProcessingInstruction = isProcessingInstruction;
     }
 
@@ -29,32 +26,40 @@ public class XmlDeclaration extends Node {
         return "#declaration";
     }
 
-
-    /**
-     * Get the name of this declaration.
-     * @return name of this declaration.
-     */
-    public String name() {
-        return name;
-    }
-
     /**
      Get the unencoded XML declaration.
      @return XML declaration
      */
     public String getWholeDeclaration() {
-        return attributes.html().trim(); // attr html starts with a " "
+        final String decl = attributes.get(DECL_KEY);
+        
+        if(decl.equals("xml") && attributes.size() > 1 ) {
+            StringBuilder sb = new StringBuilder(decl);
+            final String version = attributes.get("version");
+            
+            if( version != null ) {
+                sb.append(" version=\"").append(version).append("\"");
+            }
+            
+            final String encoding = attributes.get("encoding");
+            
+            if( encoding != null ) {
+                sb.append(" encoding=\"").append(encoding).append("\"");
+            }
+            
+            return sb.toString();
+        }
+        else {
+            return attributes.get(DECL_KEY);
+        }
     }
 
 	void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
         accum
-            .append("<")
-            .append(isProcessingInstruction ? "!" : "?")
-            .append(name);
-        attributes.html(accum, out);
-        accum
-            .append(isProcessingInstruction ? "!" : "?")
-            .append(">");
+                .append("<")
+                .append(isProcessingInstruction ? "!" : "?")
+                .append(getWholeDeclaration())
+                .append(">");
     }
 
 	void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}
diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
index 3ccd7df..99807fc 100644
--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
@@ -1,6 +1,5 @@
 package org.jsoup.parser;
 
-import org.jsoup.Jsoup;
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.*;
 
@@ -74,10 +73,8 @@ public class XmlTreeBuilder extends TreeBuilder {
             // so we do a bit of a hack and parse the data as an element to pull the attributes out
             String data = comment.getData();
             if (data.length() > 1 && (data.startsWith("!") || data.startsWith("?"))) {
-                Document doc = Jsoup.parse("<" + data.substring(1, data.length() -1) + ">", baseUri, Parser.xmlParser());
-                Element el = doc.child(0);
-                insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith("!"));
-                insert.attributes().addAll(el.attributes());
+                String declaration = data.substring(1);
+                insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith("!"));
             }
         }
         insertNode(insert);
