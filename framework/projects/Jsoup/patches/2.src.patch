diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 3fe076a..3c8e15a 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -224,11 +224,12 @@ public class HtmlTreeBuilder extends TreeBuilder {
         insertNode(el);
         if (startTag.isSelfClosing()) {
             if (tag.isKnownTag()) {
-                if (!tag.isEmpty())
-                    tokeniser.error("Tag cannot be self closing; not a void tag");
-            }
-            else // unknown tag, remember this is self closing for output
+                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error
+            } else {
+                // unknown tag, remember this is self closing for output
                 tag.setSelfClosing();
+                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error
+            }
         }
         return el;
     }
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index e837383..9a118eb 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -466,6 +466,7 @@ enum HtmlTreeBuilderState {
                         if (tb.getFormElement() != null)
                             return false;
 
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
                         tb.processStartTag("form");
                         if (startTag.attributes.hasKey("action")) {
                             Element form = tb.getFormElement();
@@ -539,10 +540,12 @@ enum HtmlTreeBuilderState {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "math" (i.e. foreign, mathml)
                         tb.insert(startTag);
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
                     } else if (name.equals("svg")) {
                         tb.reconstructFormattingElements();
                         // todo: handle A start tag whose tag name is "svg" (xlink, svg)
                         tb.insert(startTag);
+                        tb.tokeniser.acknowledgeSelfClosingFlag();
                     } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {
                         tb.error(this);
                         return false;
diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java
index b047940..1526c2a 100644
--- a/src/main/java/org/jsoup/parser/Tokeniser.java
+++ b/src/main/java/org/jsoup/parser/Tokeniser.java
@@ -33,6 +33,7 @@ final class Tokeniser {
     Token.Doctype doctypePending = new Token.Doctype(); // doctype building up
     Token.Comment commentPending = new Token.Comment(); // comment building up
     private String lastStartTag; // the last start tag emitted, to test appropriate end tag
+    private boolean selfClosingFlagAcknowledged = true;
 
     Tokeniser(CharacterReader reader, ParseErrorList errors) {
         this.reader = reader;
@@ -40,6 +41,11 @@ final class Tokeniser {
     }
 
     Token read() {
+        if (!selfClosingFlagAcknowledged) {
+            error("Self closing flag not acknowledged");
+            selfClosingFlagAcknowledged = true;
+        }
+
         while (!isEmitPending)
             state.read(this, reader);
 
@@ -68,6 +74,8 @@ final class Tokeniser {
         if (token.type == Token.TokenType.StartTag) {
             Token.StartTag startTag = (Token.StartTag) token;
             lastStartTag = startTag.tagName;
+            if (startTag.selfClosing)
+                selfClosingFlagAcknowledged = false;
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
             if (endTag.attributes != null)
@@ -114,6 +122,10 @@ final class Tokeniser {
         this.state = state;
     }
 
+    void acknowledgeSelfClosingFlag() {
+        selfClosingFlagAcknowledged = true;
+    }
+
     final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays
     final private int[] multipointHolder = new int[2];
     int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
@@ -240,7 +252,7 @@ final class Tokeniser {
             errors.add(new ParseError(reader.pos(), "Invalid character reference: %s", message));
     }
 
-    void error(String errorMsg) {
+    private void error(String errorMsg) {
         if (errors.canAddError())
             errors.add(new ParseError(reader.pos(), errorMsg));
     }
diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
index 0507243..082b585 100644
--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
@@ -72,6 +72,7 @@ public class XmlTreeBuilder extends TreeBuilder {
         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
         insertNode(el);
         if (startTag.isSelfClosing()) {
+            tokeniser.acknowledgeSelfClosingFlag();
             if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
                 tag.setSelfClosing();
         } else {
