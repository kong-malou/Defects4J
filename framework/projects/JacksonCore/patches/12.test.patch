diff --git a/src/test/java/com/fasterxml/jackson/core/json/StringGenerationTest.java b/src/test/java/com/fasterxml/jackson/core/json/StringGenerationTest.java
deleted file mode 100644
index b36cbe6..0000000
--- a/src/test/java/com/fasterxml/jackson/core/json/StringGenerationTest.java
+++ /dev/null
@@ -1,293 +0,0 @@
-package com.fasterxml.jackson.core.json;
-
-import java.io.*;
-
-import com.fasterxml.jackson.core.*;
-
-import java.util.Random;
-
-/**
- * Set of basic unit tests for verifying that the string
- * generation, including character escaping, works as expected.
- */
-public class StringGenerationTest
-    extends BaseTest
-{
-    final static String[] SAMPLES = new String[] {
-        "\"test\"",
-        "\n", "\\n", "\r\n", "a\\b", "tab:\nok?",
-        "a\tb\tc\n\fdef\t \tg\"\"\"h\"\\ijklmn\b",
-        "\"\"\"", "\\r)'\"",
-        "Longer text & other stuff:\twith some\r\n\r\n random linefeeds etc added in to cause some \"special\" handling \\\\ to occur...\n"
-    };
- 
-    private final JsonFactory FACTORY = new JsonFactory();
-    
-    public void testBasicEscaping() throws Exception
-    {
-        doTestBasicEscaping(false);
-        doTestBasicEscaping(true);
-    }
-
-    // for [core#194]
-    public void testMediumStringsBytes() throws Exception
-    {
-        _testMediumStrings(true, 1100);
-        _testMediumStrings(true, 2300);
-        _testMediumStrings(true, 3800);
-        _testMediumStrings(true, 7500);
-        _testMediumStrings(true, 19000);
-    }
-
-    // for [core#194]
-    public void testMediumStringsChars() throws Exception
-    {
-        _testMediumStrings(false, 1100);
-        _testMediumStrings(false, 2300);
-        _testMediumStrings(false, 3800);
-        _testMediumStrings(false, 7500);
-        _testMediumStrings(false, 19000);
-    }
-
-    public void testLongerRandomSingleChunk() throws Exception
-    {
-        /* Let's first generate 100k of pseudo-random characters, favoring
-         * 7-bit ascii range
-         */
-        for (int round = 0; round < 80; ++round) {
-            String content = generateRandom(75000+round);
-            doTestLongerRandom(content, false);
-            doTestLongerRandom(content, true);
-        }
-    }
-
-    public void testLongerRandomMultiChunk() throws Exception
-    {
-        /* Let's first generate 100k of pseudo-random characters, favoring
-         * 7-bit ascii range
-         */
-        for (int round = 0; round < 70; ++round) {
-            String content = generateRandom(73000+round);
-            doTestLongerRandomMulti(content, false, round);
-            doTestLongerRandomMulti(content, true, round);
-        }
-    }
-
-    /*
-    /**********************************************************
-    /* Internal methods
-    /**********************************************************
-     */
-
-    private String _generareMediumText(int minLen)
-    {
-        StringBuilder sb = new StringBuilder(minLen + 1000);
-        Random rnd = new Random(minLen);
-        do {
-            switch (rnd.nextInt() % 4) {
-            case 0:
-                sb.append(" foo");
-                break;
-            case 1:
-                sb.append(" bar");
-                break;
-            case 2:
-                sb.append(String.valueOf(sb.length()));
-                break;
-            default:
-                sb.append(" \"stuff\"");
-                break;
-            }
-        } while (sb.length() < minLen);
-        return sb.toString();
-    }
-    
-    private String generateRandom(int len)
-    {
-        StringBuilder sb = new StringBuilder(len+1000); // pad for surrogates
-        Random r = new Random(len);
-        for (int i = 0; i < len; ++i) {
-            if (r.nextBoolean()) { // non-ascii
-                int value = r.nextInt() & 0xFFFF;
-                // Otherwise easy, except that need to ensure that
-                // surrogates are properly paired: and, also
-                // their values do not exceed 0x10FFFF
-                if (value >= 0xD800 && value <= 0xDFFF) {
-                    // Let's discard first value, then, and produce valid pair
-                    int fullValue = (r.nextInt() & 0xFFFFF);
-                    sb.append((char) (0xD800 + (fullValue >> 10)));
-                    value = 0xDC00 + (fullValue & 0x3FF);
-                }
-                sb.append((char) value);
-            } else { // ascii
-                sb.append((char) (r.nextInt() & 0x7F));
-            }
-        }
-        return sb.toString();
-    }
-
-    private void _testMediumStrings(boolean useBinary, int length) throws Exception
-    {
-        String text = _generareMediumText(length);
-        StringWriter sw = new StringWriter();
-        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-
-        JsonGenerator gen = useBinary ? FACTORY.createGenerator(bytes)
-                : FACTORY.createGenerator(sw);
-        gen.writeStartArray();
-        gen.writeString(text);
-        gen.writeEndArray();
-        gen.close();
-
-        String json;
-        if (useBinary) {
-            json = bytes.toString("UTF-8");
-        } else {
-            json = sw.toString();
-        }
-
-        JsonParser p = FACTORY.createParser(json);
-        assertToken(JsonToken.START_ARRAY, p.nextToken());
-        assertToken(JsonToken.VALUE_STRING, p.nextToken());
-        assertEquals(text, p.getText());
-        assertToken(JsonToken.END_ARRAY, p.nextToken());
-        p.close();
-    }
-    
-    private void doTestBasicEscaping(boolean charArray)
-        throws Exception
-    {
-        for (int i = 0; i < SAMPLES.length; ++i) {
-            String VALUE = SAMPLES[i];
-            StringWriter sw = new StringWriter();
-            JsonGenerator gen = FACTORY.createGenerator(sw);
-            gen.writeStartArray();
-            if (charArray) {
-                char[] buf = new char[VALUE.length() + i];
-                VALUE.getChars(0, VALUE.length(), buf, i);
-                gen.writeString(buf, i, VALUE.length());
-            } else {
-                gen.writeString(VALUE);
-            }
-            gen.writeEndArray();
-            gen.close();
-            String docStr = sw.toString();
-            JsonParser jp = createParserUsingReader(docStr);
-            assertEquals(JsonToken.START_ARRAY, jp.nextToken());
-            JsonToken t = jp.nextToken();
-            assertEquals(JsonToken.VALUE_STRING, t);
-            assertEquals(VALUE, jp.getText());
-            assertEquals(JsonToken.END_ARRAY, jp.nextToken());
-            assertEquals(null, jp.nextToken());
-            jp.close();
-        }
-    }
-
-    private void doTestLongerRandom(String text, boolean charArray)
-        throws Exception
-    {
-        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());
-        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
-
-        gen.writeStartArray();
-        if (charArray) {
-            char[] buf = new char[text.length()];
-            text.getChars(0, text.length(), buf, 0);
-            gen.writeString(buf, 0, text.length());
-        } else {
-            gen.writeString(text);
-        }
-        gen.writeEndArray();
-        gen.close();
-        byte[] docData = bow.toByteArray();
-        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));
-        assertEquals(JsonToken.START_ARRAY, jp.nextToken());
-        JsonToken t = jp.nextToken();
-        assertEquals(JsonToken.VALUE_STRING, t);
-        String act = jp.getText();
-        if (!text.equals(act)) {
-            if (text.length() != act.length()) {
-                fail("Expected string length "+text.length()+", actual "+act.length());
-            }
-            int i = 0;
-            for (int len = text.length(); i < len; ++i) {
-                if (text.charAt(i) != act.charAt(i)) {
-                    break;
-                }
-            }
-            fail("Strings differ at position #"+i+" (len "+text.length()+"): expected char 0x"+Integer.toHexString(text.charAt(i))+", actual 0x"+Integer.toHexString(act.charAt(i)));
-        }
-        assertEquals(JsonToken.END_ARRAY, jp.nextToken());
-        assertEquals(null, jp.nextToken());
-        jp.close();
-    }
-
-    private void doTestLongerRandomMulti(String text, boolean charArray, int round)
-        throws Exception
-    {
-        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());
-        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
-        gen.writeStartArray();
-
-        gen.writeString(text);
-        gen.writeEndArray();
-        gen.close();
-        
-        gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
-        gen.writeStartArray();
-        gen.writeStartArray();
-
-        Random rnd = new Random(text.length());
-        int offset = 0;
-
-        while (offset < text.length()) {
-            int shift = 1 + ((rnd.nextInt() & 0xFFFFF) % 12); // 1 - 12
-            int len = (1 << shift) + shift; // up to 4k
-            if ((offset + len) >= text.length()) {
-                len = text.length() - offset;
-            } else {
-            	// Need to avoid splitting surrogates though
-            	char c = text.charAt(offset+len-1);
-            	if (c >= 0xD800 && c < 0xDC00) {
-            		++len;
-            	}
-            }
-            if (charArray) {
-                char[] buf = new char[len];
-                text.getChars(offset, offset+len, buf, 0);
-                gen.writeString(buf, 0, len);
-            } else {
-                gen.writeString(text.substring(offset, offset+len));
-            }
-            offset += len;
-        }
-
-        gen.writeEndArray();
-        gen.close();
-        byte[] docData = bow.toByteArray();
-        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));
-        assertEquals(JsonToken.START_ARRAY, jp.nextToken());
-
-        offset = 0;
-        while (jp.nextToken() == JsonToken.VALUE_STRING) {
-            // Let's verify, piece by piece
-            String act = jp.getText();
-            String exp = text.substring(offset, offset+act.length());
-            if (act.length() != exp.length()) {
-                fail("String segment ["+offset+" - "+(offset+act.length())+"[ differs; exp length "+exp+", actual "+act);                
-            }
-            if (!act.equals(exp)) {
-                int i = 0;
-                while (act.charAt(i) == exp.charAt(i)) {
-                    ++i;
-                }
-                fail("String segment ["+offset+" - "+(offset+act.length())+"[ different at offset #"+i
-                        +"; exp char 0x"+Integer.toHexString(exp.charAt(i))
-                        +", actual 0x"+Integer.toHexString(act.charAt(i)));
-            }
-            offset += act.length();
-        }
-        assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken());
-        jp.close();
-    }
-}
diff --git a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java
index 2dd03b8..820e208 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java
@@ -11,12 +11,11 @@ import java.io.*;
 public class TestJsonGenerator
     extends com.fasterxml.jackson.core.BaseTest
 {
-    private final JsonFactory JSON_F = new JsonFactory();
-
     // // // First, tests for primitive (non-structured) values
 
     public void testStringWrite() throws Exception
     {
+        JsonFactory jf = new JsonFactory();
         String[] inputStrings = new String[] { "", "X", "1234567890" };
         for (int useReader = 0; useReader < 2; ++useReader) {
             for (int writeString = 0; writeString < 2; ++writeString) {
@@ -25,9 +24,9 @@ public class TestJsonGenerator
                     JsonGenerator gen;
                     ByteArrayOutputStream bout = new ByteArrayOutputStream();
                     if (useReader != 0) {
-                        gen = JSON_F.createGenerator(new OutputStreamWriter(bout, "UTF-8"));
+                        gen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8"));
                     } else {
-                        gen = JSON_F.createGenerator(bout, JsonEncoding.UTF8);
+                        gen = jf.createGenerator(bout, JsonEncoding.UTF8);
                     }
                     if (writeString > 0) {
                         gen.writeString(input);
@@ -40,7 +39,7 @@ public class TestJsonGenerator
                     }
                     gen.flush();
                     gen.close();
-                    JsonParser jp = JSON_F.createParser(new ByteArrayInputStream(bout.toByteArray()));
+                    JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray()));
                 
                     JsonToken t = jp.nextToken();
                     assertNotNull("Document \""+bout.toString("UTF-8")+"\" yielded no tokens", t);
@@ -53,16 +52,16 @@ public class TestJsonGenerator
         }
     }
 
-    public void testIntValueWrite() throws Exception
+    public void testIntWrite() throws Exception
     {
-        doTestIntValueWrite(false);
-        doTestIntValueWrite(true);
+        doTestIntWrite(false);
+        doTestIntWrite(true);
     }
 
-    public void testLongValueWrite() throws Exception
+    public void testLongWrite() throws Exception
     {
-        doTestLongValueWrite(false);
-        doTestLongValueWrite(true);
+        doTestLongWrite(false);
+        doTestLongWrite(true);
     }
 
     public void testBooleanWrite() throws Exception
@@ -71,7 +70,7 @@ public class TestJsonGenerator
             boolean state = (i & 1) == 0;
             boolean pad = (i & 2) == 0;
             StringWriter sw = new StringWriter();
-            JsonGenerator gen = JSON_F.createGenerator(sw);
+            JsonGenerator gen = new JsonFactory().createGenerator(sw);
             gen.writeBoolean(state);
             if (pad) {
                 gen.writeRaw(" ");
@@ -96,7 +95,7 @@ public class TestJsonGenerator
         for (int i = 0; i < 2; ++i) {
             boolean pad = (i & 1) == 0;
             StringWriter sw = new StringWriter();
-            JsonGenerator gen = JSON_F.createGenerator(sw);
+            JsonGenerator gen = new JsonFactory().createGenerator(sw);
             gen.writeNull();
             if (pad) {
                 gen.writeRaw(" ");
@@ -121,7 +120,7 @@ public class TestJsonGenerator
          throws Exception
      {
          StringWriter sw = new StringWriter();
-         JsonGenerator gen = JSON_F.createGenerator(sw);
+         JsonGenerator gen = new JsonFactory().createGenerator(sw);
          gen.writeNumber(1);
          gen.writeNumber(2);
          gen.writeNumber(-13);
@@ -145,7 +144,7 @@ public class TestJsonGenerator
          throws Exception
      {
          StringWriter sw = new StringWriter();
-         JsonGenerator gen = JSON_F.createGenerator(sw);
+         JsonGenerator gen = new JsonFactory().createGenerator(sw);
          gen.writeStartObject();
          gen.writeNumberField("long", 3L);
          gen.writeNumberField("double", 0.25);
@@ -162,7 +161,7 @@ public class TestJsonGenerator
     public void testOutputContext() throws Exception
     {
         StringWriter sw = new StringWriter();
-        JsonGenerator gen = JSON_F.createGenerator(sw);
+        JsonGenerator gen = new JsonFactory().createGenerator(sw);
         JsonStreamContext ctxt = gen.getOutputContext();
         assertTrue(ctxt.inRoot());
 
@@ -233,7 +232,7 @@ public class TestJsonGenerator
     /**********************************************************
      */
 
-    private void doTestIntValueWrite(boolean pad) throws Exception
+    private void doTestIntWrite(boolean pad) throws Exception
     {
         int[] VALUES = new int[] {
             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,
@@ -242,7 +241,7 @@ public class TestJsonGenerator
         for (int i = 0; i < VALUES.length; ++i) {
             int VALUE = VALUES[i];
             StringWriter sw = new StringWriter();
-            JsonGenerator gen = JSON_F.createGenerator(sw);
+            JsonGenerator gen = new JsonFactory().createGenerator(sw);
             gen.writeNumber(VALUE);
             if (pad) {
                 gen.writeRaw(" ");
@@ -264,7 +263,8 @@ public class TestJsonGenerator
         }
     }
 
-    private void doTestLongValueWrite(boolean pad) throws Exception
+    private void doTestLongWrite(boolean pad)
+        throws Exception
     {
         long[] VALUES = new long[] {
             0L, 1L, -1L, -12005002294L, Long.MIN_VALUE, Long.MAX_VALUE
@@ -272,7 +272,7 @@ public class TestJsonGenerator
         for (int i = 0; i < VALUES.length; ++i) {
             long VALUE = VALUES[i];
             StringWriter sw = new StringWriter();
-            JsonGenerator gen = JSON_F.createGenerator(sw);
+            JsonGenerator gen = new JsonFactory().createGenerator(sw);
             gen.writeNumber(VALUE);
             if (pad) {
                 gen.writeRaw(" ");
@@ -293,4 +293,3 @@ public class TestJsonGenerator
         }
     }
 }
-
diff --git a/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java b/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java
new file mode 100644
index 0000000..ed167e6
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java
@@ -0,0 +1,225 @@
+package com.fasterxml.jackson.core.main;
+
+import java.io.*;
+
+import com.fasterxml.jackson.core.*;
+
+import java.util.Random;
+
+/**
+ * Set of basic unit tests for verifying that the string
+ * generation, including character escaping, works as expected.
+ */
+public class TestStringGeneration
+    extends BaseTest
+{
+    final static String[] SAMPLES = new String[] {
+        "\"test\"",
+        "\n", "\\n", "\r\n", "a\\b", "tab:\nok?",
+        "a\tb\tc\n\fdef\t \tg\"\"\"h\"\\ijklmn\b",
+        "\"\"\"", "\\r)'\"",
+        "Longer text & other stuff:\twith some\r\n\r\n random linefeeds etc added in to cause some \"special\" handling \\\\ to occur...\n"
+    };
+ 
+    private final JsonFactory FACTORY = new JsonFactory();
+    
+    public void testBasicEscaping()
+        throws Exception
+    {
+        doTestBasicEscaping(false);
+        doTestBasicEscaping(true);
+    }
+
+    public void testLongerRandomSingleChunk()
+        throws Exception
+    {
+        /* Let's first generate 100k of pseudo-random characters, favoring
+         * 7-bit ascii range
+         */
+        for (int round = 0; round < 80; ++round) {
+            String content = generateRandom(75000+round);
+            doTestLongerRandom(content, false);
+            doTestLongerRandom(content, true);
+        }
+    }
+
+    public void testLongerRandomMultiChunk()
+        throws Exception
+    {
+        /* Let's first generate 100k of pseudo-random characters, favoring
+         * 7-bit ascii range
+         */
+        for (int round = 0; round < 70; ++round) {
+            String content = generateRandom(73000+round);
+            doTestLongerRandomMulti(content, false, round);
+            doTestLongerRandomMulti(content, true, round);
+        }
+    }
+
+    /*
+    /**********************************************************
+    /* Internal methods
+    /**********************************************************
+     */
+
+    private String generateRandom(int len)
+    {
+        StringBuilder sb = new StringBuilder(len+1000); // pad for surrogates
+        Random r = new Random(len);
+        for (int i = 0; i < len; ++i) {
+            if (r.nextBoolean()) { // non-ascii
+                int value = r.nextInt() & 0xFFFF;
+                // Otherwise easy, except that need to ensure that
+                // surrogates are properly paired: and, also
+                // their values do not exceed 0x10FFFF
+                if (value >= 0xD800 && value <= 0xDFFF) {
+                    // Let's discard first value, then, and produce valid pair
+                    int fullValue = (r.nextInt() & 0xFFFFF);
+                    sb.append((char) (0xD800 + (fullValue >> 10)));
+                    value = 0xDC00 + (fullValue & 0x3FF);
+                }
+                sb.append((char) value);
+            } else { // ascii
+                sb.append((char) (r.nextInt() & 0x7F));
+            }
+        }
+        return sb.toString();
+    }   
+
+    private void doTestBasicEscaping(boolean charArray)
+        throws Exception
+    {
+        for (int i = 0; i < SAMPLES.length; ++i) {
+            String VALUE = SAMPLES[i];
+            StringWriter sw = new StringWriter();
+            JsonGenerator gen = FACTORY.createGenerator(sw);
+            gen.writeStartArray();
+            if (charArray) {
+                char[] buf = new char[VALUE.length() + i];
+                VALUE.getChars(0, VALUE.length(), buf, i);
+                gen.writeString(buf, i, VALUE.length());
+            } else {
+                gen.writeString(VALUE);
+            }
+            gen.writeEndArray();
+            gen.close();
+            String docStr = sw.toString();
+            JsonParser jp = createParserUsingReader(docStr);
+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());
+            JsonToken t = jp.nextToken();
+            assertEquals(JsonToken.VALUE_STRING, t);
+            assertEquals(VALUE, jp.getText());
+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());
+            assertEquals(null, jp.nextToken());
+            jp.close();
+        }
+    }
+
+    private void doTestLongerRandom(String text, boolean charArray)
+        throws Exception
+    {
+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());
+        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
+
+        gen.writeStartArray();
+        if (charArray) {
+            char[] buf = new char[text.length()];
+            text.getChars(0, text.length(), buf, 0);
+            gen.writeString(buf, 0, text.length());
+        } else {
+            gen.writeString(text);
+        }
+        gen.writeEndArray();
+        gen.close();
+        byte[] docData = bow.toByteArray();
+        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));
+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());
+        JsonToken t = jp.nextToken();
+        assertEquals(JsonToken.VALUE_STRING, t);
+        String act = jp.getText();
+        if (!text.equals(act)) {
+            if (text.length() != act.length()) {
+                fail("Expected string length "+text.length()+", actual "+act.length());
+            }
+            int i = 0;
+            for (int len = text.length(); i < len; ++i) {
+                if (text.charAt(i) != act.charAt(i)) {
+                    break;
+                }
+            }
+            fail("Strings differ at position #"+i+" (len "+text.length()+"): expected char 0x"+Integer.toHexString(text.charAt(i))+", actual 0x"+Integer.toHexString(act.charAt(i)));
+        }
+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());
+        assertEquals(null, jp.nextToken());
+        jp.close();
+    }
+
+    private void doTestLongerRandomMulti(String text, boolean charArray, int round)
+        throws Exception
+    {
+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());
+        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
+        gen.writeStartArray();
+
+        gen.writeString(text);
+        gen.writeEndArray();
+        gen.close();
+        
+        gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);
+        gen.writeStartArray();
+        gen.writeStartArray();
+
+        Random rnd = new Random(text.length());
+        int offset = 0;
+
+        while (offset < text.length()) {
+            int shift = 1 + ((rnd.nextInt() & 0xFFFFF) % 12); // 1 - 12
+            int len = (1 << shift) + shift; // up to 4k
+            if ((offset + len) >= text.length()) {
+                len = text.length() - offset;
+            } else {
+            	// Need to avoid splitting surrogates though
+            	char c = text.charAt(offset+len-1);
+            	if (c >= 0xD800 && c < 0xDC00) {
+            		++len;
+            	}
+            }
+            if (charArray) {
+                char[] buf = new char[len];
+                text.getChars(offset, offset+len, buf, 0);
+                gen.writeString(buf, 0, len);
+            } else {
+                gen.writeString(text.substring(offset, offset+len));
+            }
+            offset += len;
+        }
+
+        gen.writeEndArray();
+        gen.close();
+        byte[] docData = bow.toByteArray();
+        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));
+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());
+
+        offset = 0;
+        while (jp.nextToken() == JsonToken.VALUE_STRING) {
+            // Let's verify, piece by piece
+            String act = jp.getText();
+            String exp = text.substring(offset, offset+act.length());
+            if (act.length() != exp.length()) {
+                fail("String segment ["+offset+" - "+(offset+act.length())+"[ differs; exp length "+exp+", actual "+act);                
+            }
+            if (!act.equals(exp)) {
+                int i = 0;
+                while (act.charAt(i) == exp.charAt(i)) {
+                    ++i;
+                }
+                fail("String segment ["+offset+" - "+(offset+act.length())+"[ different at offset #"+i
+                        +"; exp char 0x"+Integer.toHexString(exp.charAt(i))
+                        +", actual 0x"+Integer.toHexString(act.charAt(i)));
+            }
+            offset += act.length();
+        }
+        assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken());
+        jp.close();
+    }
+}
