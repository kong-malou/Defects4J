diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
index a530e4b..7cd0d82 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
@@ -162,39 +162,36 @@ public class CreatorCollector
             SettableBeanProperty[] injectables)
     {
         if (creator.getParameterType(0).isCollectionLikeType()) {
-            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {
-                _arrayDelegateArgs = injectables;
-            }
+            verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);
+            _arrayDelegateArgs = injectables;
         } else {
-            if (verifyNonDup(creator, C_DELEGATE, explicit)) {
-                _delegateArgs = injectables;
-            }
+            verifyNonDup(creator, C_DELEGATE, explicit);
+            _delegateArgs = injectables;
         }
     }
     
     public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,
             SettableBeanProperty[] properties)
     {
-        if (verifyNonDup(creator, C_PROPS, explicit)) {
-            // Better ensure we have no duplicate names either...
-            if (properties.length > 1) {
-                HashMap<String,Integer> names = new HashMap<String,Integer>();
-                for (int i = 0, len = properties.length; i < len; ++i) {
-                    String name = properties[i].getName();
-                    /* [Issue-13]: Need to consider Injectables, which may not have
-                     *   a name at all, and need to be skipped
-                     */
-                    if (name.length() == 0 && properties[i].getInjectableValueId() != null) {
-                        continue;
-                    }
-                    Integer old = names.put(name, Integer.valueOf(i));
-                    if (old != null) {
-                        throw new IllegalArgumentException("Duplicate creator property \""+name+"\" (index "+old+" vs "+i+")");
-                    }
+        verifyNonDup(creator, C_PROPS, explicit);
+        // Better ensure we have no duplicate names either...
+        if (properties.length > 1) {
+            HashMap<String,Integer> names = new HashMap<String,Integer>();
+            for (int i = 0, len = properties.length; i < len; ++i) {
+                String name = properties[i].getName();
+                /* [Issue-13]: Need to consider Injectables, which may not have
+                 *   a name at all, and need to be skipped
+                 */
+                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {
+                    continue;
+                }
+                Integer old = names.put(name, Integer.valueOf(i));
+                if (old != null) {
+                    throw new IllegalArgumentException("Duplicate creator property \""+name+"\" (index "+old+" vs "+i+")");
                 }
             }
-            _propertyBasedArgs = properties;
         }
+        _propertyBasedArgs = properties;
     }
 
     public void addIncompeteParameter(AnnotatedParameter parameter) {
@@ -296,10 +293,7 @@ public class CreatorCollector
         return member;
     }
 
-    /**
-     * @return True if specified Creator is to be used
-     */
-    protected boolean verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
+    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
     {
         final int mask = (1 << typeIndex);
         _hasNonDefaultCreator = true;
@@ -310,7 +304,7 @@ public class CreatorCollector
             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                 // but skip, if new one not annotated
                 if (!explicit) {
-                    return false;
+                    return;
                 }
                 // both explicit: verify
                 verify = true;
@@ -332,7 +326,7 @@ public class CreatorCollector
                 // otherwise, which one to choose?
                 if (newType.isAssignableFrom(oldType)) {
                     // new type more generic, use old
-                    return false;
+                    return;
                 }
                 // new type more specific, use it
             }
@@ -341,7 +335,6 @@ public class CreatorCollector
             _explicitCreators |= mask;
         }
         _creators[typeIndex] = _fixAccess(newOne);
-        return true;
     }
 
     /*
