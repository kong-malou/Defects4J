diff --git a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
index c0e79c8..892c688 100644
--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
@@ -15,44 +15,7 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
 {
     protected final static MappingIterator<?> EMPTY_ITERATOR =
         new MappingIterator<Object>(null, null, null, null, false, null);
-
-    /*
-    /**********************************************************
-    /* State constants
-    /**********************************************************
-     */
-
-    /**
-     * State in which iterator is closed
-     */
-    protected final static int STATE_CLOSED = 0;
-    
-    /**
-     * State in which value read failed
-     */
-    protected final static int STATE_NEED_RESYNC = 1;
     
-    /**
-     * State in which no recovery is needed, but "hasNextValue()" needs
-     * to be called first
-     */
-    protected final static int STATE_MAY_HAVE_VALUE = 2;
-
-    /**
-     * State in which "hasNextValue()" has been succesfully called
-     * and deserializer can be called to fetch value
-     */
-    protected final static int STATE_HAS_VALUE = 3;
-
-    /*
-    /**********************************************************
-    /* Configuration
-    /**********************************************************
-     */
-
-    /**
-     * Type to bind individual elements to.
-     */
     protected final JavaType _type;
 
     /**
@@ -65,20 +28,9 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      */
     protected final JsonDeserializer<T> _deserializer;
 
-    /**
-     * Underlying parser used for reading content to bind. Initialized
-     * as not <code>null</code> but set as <code>null</null> when
-     * iterator is closed, to denote closing.
-     */
-    protected final JsonParser _parser;
+    protected JsonParser _parser;
 
     /**
-     * Context to resynchronize to, in case an exception is encountered
-     * but caller wants to try to read more elements.
-     */
-    protected final JsonStreamContext _seqContext;
-    
-    /**
      * If not null, "value to update" instead of creating a new instance
      * for each call.
      */
@@ -100,7 +52,7 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**
      * State of the iterator
      */
-    protected int _state;
+    protected boolean _hasNextChecked;
 
     /*
     /**********************************************************
@@ -115,12 +67,12 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      *   closed by iterator.
      */
     @SuppressWarnings("unchecked")
-    protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,
+    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,
             JsonDeserializer<?> deser,
             boolean managedParser, Object valueToUpdate)
     {
         _type = type;
-        _parser = p;
+        _parser = jp;
         _context = ctxt;
         _deserializer = (JsonDeserializer<T>) deser;
         _closeParser = managedParser;
@@ -140,25 +92,8 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
          * and if not, caller needs to hand us JsonParser instead, pointing to
          * the first token of the first element.
          */
-        if (p == null) { // can this occur?
-            _seqContext = null;
-            _state = STATE_CLOSED;
-        } else {
-            JsonStreamContext sctxt = p.getParsingContext();
-            if (managedParser && p.isExpectedStartArrayToken()) {
-                // If pointing to START_ARRAY, context should be that ARRAY
-                p.clearCurrentToken();
-            } else {
-                // regardless, recovery context should be whatever context we have now,
-                // with sole exception of pointing to a start marker, in which case it's
-                // the parent
-                JsonToken t = p.getCurrentToken();
-                if ((t == JsonToken.START_OBJECT) || (t == JsonToken.START_ARRAY)) {
-                    sctxt = sctxt.getParent();
-                }
-            }
-            _seqContext = sctxt;
-            _state = STATE_MAY_HAVE_VALUE;
+        if (managedParser && (jp != null) && jp.isExpectedStartArrayToken()) {
+            jp.clearCurrentToken();
         }
     }
 
@@ -203,12 +138,9 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     }
     
     @Override
-    public void close() throws IOException {
-        if (_state != STATE_CLOSED) {
-            _state = STATE_CLOSED;
-            if (_parser != null) {
-                _parser.close();
-            }
+    public void close() throws IOException{
+        if (_parser != null) {
+            _parser.close();
         }
     }
 
@@ -228,61 +160,49 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
      */
     public boolean hasNextValue() throws IOException
     {
-        switch (_state) {
-        case STATE_CLOSED:
+        if (_parser == null) {
             return false;
-        case STATE_NEED_RESYNC:
-            _resync();
-            // fall-through
-        case STATE_MAY_HAVE_VALUE:
+        }
+        if (!_hasNextChecked) {
             JsonToken t = _parser.getCurrentToken();
+            _hasNextChecked = true;
             if (t == null) { // un-initialized or cleared; find next
                 t = _parser.nextToken();
                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
                 if (t == null || t == JsonToken.END_ARRAY) {
-                    _state = STATE_CLOSED;
-                    if (_closeParser && (_parser != null)) {
-                        _parser.close();
+                    JsonParser jp = _parser;
+                    _parser = null;
+                    if (_closeParser) {
+                        jp.close();
                     }
                     return false;
                 }
             }
-            _state = STATE_HAS_VALUE;
-            return true;
-        case STATE_HAS_VALUE:
-            // fall through
         }
         return true;
     }
 
     public T nextValue() throws IOException
     {
-        switch (_state) {
-        case STATE_CLOSED:
-            return _throwNoSuchElement();
-        case STATE_NEED_RESYNC: // fall-through, will do re-sync
-        case STATE_MAY_HAVE_VALUE:
+        // caller should always call 'hasNext[Value]' first; but let's ensure:
+        if (!_hasNextChecked) {
             if (!hasNextValue()) {
                 return _throwNoSuchElement();
             }
-            break;
-        case STATE_HAS_VALUE:
-            break;
         }
+        if (_parser == null) {
+            return _throwNoSuchElement();
+        }
+        _hasNextChecked = false;
 
-        int nextState = STATE_NEED_RESYNC;
         try {
-            T value;
             if (_updatedValue == null) {
-                value = _deserializer.deserialize(_parser, _context);
+                return _deserializer.deserialize(_parser, _context);
             } else{
                 _deserializer.deserialize(_parser, _context, _updatedValue);
-                value = _updatedValue;
+                return _updatedValue;
             }
-            nextState = STATE_MAY_HAVE_VALUE;
-            return value;
         } finally {
-            _state = nextState;
             /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
              *   matter what, to avoid infinite loop for certain failure cases.
              *   For 2.6 need to improve further.
@@ -379,29 +299,6 @@ public class MappingIterator<T> implements Iterator<T>, Closeable
     /**********************************************************
      */
 
-    protected void _resync() throws IOException
-    {
-        final JsonParser p = _parser;
-        // First, a quick check to see if we might have been lucky and no re-sync needed
-        if (p.getParsingContext() == _seqContext) {
-            return;
-        }
-
-        while (true) {
-            JsonToken t = p.nextToken();
-            if ((t == JsonToken.END_ARRAY) || (t == JsonToken.END_OBJECT)) {
-                if (p.getParsingContext() == _seqContext) {
-                    p.clearCurrentToken();
-                    return;
-                }
-            } else if ((t == JsonToken.START_ARRAY) || (t == JsonToken.START_OBJECT)) {
-                p.skipChildren();
-            } else if (t == null) {
-                return;
-            }
-        }
-    }
-
     protected <R> R _throwNoSuchElement() {
         throw new NoSuchElementException();
     }
